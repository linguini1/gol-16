; INSTRUCTION FETCHING STATES ------------------------------------------------------------------------------------------
f0: ; mar <- [pc], t1 <- [pc]
    pcoe, regr, marce, t1ce, anop, #f1

f1: ; mdr <- Mmem[[mar]], t2 <- pc++
    maroe, ibread, mdrce, aadd, coe, t2ce, #f2

f2: ; ir <- [mdr]
    irce, mdroe, mdrget, anop, #decode

; SPECIAL DECODE STATE -------------------------------------------------------------------------------------------------
decode: ; pc <- [t2]
    pcoe, regw, t2oe ; No next state, determined by decode ROM

; EXECUTION STATES -----------------------------------------------------------------------------------------------------

; Begin execution for Form 1 instructions using registers ------------------------------------------
ex0: ; t1 <- [rx]
    rx, regr, t1ce, anop, #ex1

ex1: ; t2 <- [t1] <op> [ry]
    ry, regr, t1oe, aop, t2ce, #ex2

ex2: ; rd <- [t2]
    rd, regw, t2oe, anop, #f0 ; Execution complete

; Begin execution states for Form 1 instructions with immediate ------------------------------------
ex3: ; t1 <- [rx]
    rx, regr, t1ce, anop, #ex4

ex4: ; t2 <- [t1] <op> uext(imm7)
    ui7, t1oe, aop, t2ce, #ex2 ; Same final state as ex2, execution complete

; Execution states for MOV and NOT instructions using registers ------------------------------------
ex5: ; t2 <- OP([r])
    rx, regr, aop, t2ce, #ex5

ex6: ; rd <- [t2]
    rd, regw, t2oe, anop, #f0

; Execution states for MOV using an immediate value ------------------------------------------------
ex7: ; rd <- uext(imm9)
    rd, regw, ui9, anop, #f0

; Execution states for NOT
    
